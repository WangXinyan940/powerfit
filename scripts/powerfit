#! /usr/bin/python
from __future__ import print_function, division, absolute_import

from argparse import ArgumentParser
import multiprocessing as mp
from time import time
import os

import numpy as np

from powerfit import PDB, Volume, PowerFitter, Solutions
from powerfit.rotations import proportional_orientations, quat_to_rotmat
from powerfit.helpers import get_queue
from powerfit import volume

def parse_args():

    p = ArgumentParser()

    p.add_argument('model', type=str,
            help='Atomic model to be fitted in the density. ' +\
                 'Format should either be PDB or mmCIF')
    p.add_argument('map', type=str,
            help='Target density map to fit the model in. ' +\
                 'Data should either be in CCP4 or MRC format')

    p.add_argument('resolution', type=float,
            help='Resolution of map in angstrom')

    p.add_argument('-a', '--angle', dest='angle', type=float, default=10,
            help='Rotational sampling density in degree. Increasing ' +\
                 'this number by a factor of 2 results in approximately ' +\
                 '8 times more rotations sampled.')

    p.add_argument('-l', '--laplace', dest='laplace', action='store_true',
            help='Use the Laplace pre-filter density data. ' +\
                 'Can be combined ' +\
                 'with the core-weighted local cross-correlation.')

    p.add_argument('-cw', '--core-weighted', dest='core_weighted', action='store_true',
            help='Use core-weighted local cross-correlation score. ' +\
                 'Can be combined with the Laplace pre-filter.')

    p.add_argument('-n', '--num', dest='num', type=int, default=10,
            help='Number of models written to file. This number ' +\
                 'will be capped if less solutions are found as requested.')

    p.add_argument('-g', '--gpu', dest='gpu', action='store_true',
            help='Off-load the intensive calculations to the GPU. ' +\
                 'If none is found, the CPU-version is used instead.')

    p.add_argument('-p', '--nproc', dest='nproc', type=int, default=1,
            help='Number of processors used during search. ' +\
                 'The number will be capped at the total number ' +\
                 'of available processors on your machine.')

    return p.parse_args()


def run_powerfit_instance(args, vol, rotmat, n):

    pf = PowerFitter()
    pf.map = vol
    pf.model = PDB.fromfile(args.model)
    pf.resolution = args.resolution
    pf.rotations = rotmat
    pf.laplace = args.laplace
    pf.core_weighted = args.core_weighted

    sol = pf.search()
    sol.save('lcc_{:d}.mrc'.format(n),
            'rotmat_{:d}.npy'.format(n),
            'rotmat_ind_{:d}.npy'.format(n))


def cpu_powerfit(args, vol, rotmat):
        # determine the number of jobs that should be created
        nrot = rotmat.shape[0]
        try:
            jobs = min(mp.cpu_count(), args.nproc)
        except NotImplementedError:
            jobs = args.nproc
        jobs = min(jobs, nrot)
        nrot_per_job = nrot//jobs

        processes = []
        for n in range(jobs):

            init_rot = n*nrot_per_job
            end_rot = init_rot + nrot_per_job

            sub_rotmat = rotmat[init_rot: end_rot]
            if n == (jobs - 1):
                sub_rotmat = rotmat[init_rot:]

            processes.append(mp.Process(target=run_powerfit_instance,
                    args=(args, vol, sub_rotmat, n)))

        print('Starting jobs')
        for n in range(jobs):
            processes[n].start()

        print('Waiting for jobs')
        for n in range(jobs):
            processes[n].join()

        # combine results
        print('Combining results')
        best_lcc = Volume.fromfile('lcc_0.mrc')
        best_rotmat_ind = np.load('rotmat_ind_0.npy')
        for n in range(1, jobs):
            f_lcc= 'lcc_{:d}.mrc'.format(n)
            f_rotmat_ind = 'rotmat_ind_{:d}.npy'.format(n)
            lcc = Volume.fromfile(f_lcc)
            rotmat_ind = np.load(f_rotmat_ind) + nrot_per_job*n

            ind = lcc.array > best_lcc.array
            best_lcc.array[ind] = lcc.array[ind]
            best_rotmat_ind[ind] = rotmat_ind[ind]
        sol = Solutions(best_lcc, rotmat, best_rotmat_ind)

        print('Cleaning')
        for n in range(jobs):
            f_lcc= 'lcc_{:d}.mrc'.format(n)
            f_rotmat_ind = 'rotmat_ind_{:d}.npy'.format(n)
            f_rotmat = 'rotmat_{:d}.npy'.format(n)
            os.remove(f_lcc)
            os.remove(f_rotmat_ind)
            os.remove(f_rotmat)

        return sol


def gpu_powerfit(args, vol, rotmat, queue):

    pf = PowerFitter()
    pf.map = vol
    pf.model = PDB.fromfile(args.model)
    pf.resolution = args.resolution
    pf.rotations = rotmat
    pf.laplace = args.laplace
    pf.core_weighted = args.core_weighted
    pf.queue = queue

    sol = pf.search()

    return sol


def main():

    args = parse_args()

    time0 = time()

    q, w, a = proportional_orientations(args.angle)
    rotmat = quat_to_rotmat(q)

    vol = Volume.fromfile(args.map)
    print('Initial shape: ', vol.shape)
    resampling_factor = vol.voxelspacing/(0.25*args.resolution)
    if resampling_factor < 0.9:
        vol = volume.resample(vol, factor=resampling_factor)
    vol = volume.trim(vol, 0.1*vol.array.max())
    vol = volume.resize_radix235(vol)
    print('Final shape: ', vol.shape)

    queue = None
    if args.gpu:
        queue = get_queue()

    if queue is None:
        if args.gpu:
            print('GPU-queue not found. Falling back on CPU-implementation.')
        sol = cpu_powerfit(args, vol, rotmat)
    else:
        sol = gpu_powerfit(args, vol, rotmat, queue)

    print('Writing results')
    sol.save()
    sol.write_pdb(PDB.fromfile(args.model), num=args.num)
    sol.write_local_solutions()
    print('Total time: ', time() - time0)


if __name__=='__main__':
    main()
