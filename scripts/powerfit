#! /usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function, division, absolute_import

import os, errno
from sys import stdout
from time import time
from argparse import ArgumentParser, FileType
import multiprocessing as mp

import numpy as np

from powerfit import PDB, Volume, PowerFitter, Solutions
from powerfit.rotations import proportional_orientations, quat_to_rotmat
from powerfit.helpers import get_queue
from powerfit import volume

import logging

def parse_args():

    p = ArgumentParser()

    p.add_argument('model', type=file,
            help='Atomic model to be fitted in the density. '
                 'Format should either be PDB or mmCIF')

    p.add_argument('map', type=FileType('rb'),
            help='Target density map to fit the model in. '
                 'Data should either be in CCP4 or MRC format')

    p.add_argument('resolution', type=float,
            help='Resolution of map in angstrom')

    p.add_argument('-a', '--angle', dest='angle', type=float, default=10,
            help='Rotational sampling density in degree. Increasing '
                 'this number by a factor of 2 results in approximately '
                 '8 times more rotations sampled.')

    p.add_argument('-l', '--laplace', dest='laplace', action='store_true',
            help='Use the Laplace pre-filter density data. '
                 'Can be combined '
                 'with the core-weighted local cross-correlation.')

    p.add_argument('-cw', '--core-weighted', dest='core_weighted', action='store_true',
            help='Use core-weighted local cross-correlation score. '
                 'Can be combined with the Laplace pre-filter.')

    p.add_argument('-nr', '--no-resampling', dest='no_resampling', action='store_true',
            help='Do not resample the density map.')
    
    p.add_argument('-nt', '--no-trimming', dest='no_trimming', action='store_true',
            help='Do not trim the density map.')

    p.add_argument('-tc', '--trimming-cutoff', dest='trimming_cutoff', type=float, default=None,
            help='Intensity cutoff to which the map will be trimmed. '
                 'Default is 10 percent of maximum intensity.')

    p.add_argument('-c', '--chain', dest='chain', type=str, default=None,
            help='The chain ID of the structure to be fitted. '
                 'Default is the whole structure.')

    p.add_argument('-d', '--directory', dest='directory', type=str, default='.',
            help='Directory where the results are stored.')

    p.add_argument('-n', '--num', dest='num', type=int, default=10,
            help='Number of models written to file. This number '
                 'will be capped if less solutions are found as requested.')

    p.add_argument('-g', '--gpu', dest='gpu', action='store_true',
            help='Off-load the intensive calculations to the GPU. '
                 'If none is found, the CPU-version is used instead.')

    p.add_argument('-p', '--nproc', dest='nproc', type=int, default=1,
            help='Number of processors used during search. '
                 'The number will be capped at the total number '
                 'of available processors on your machine.')

    return p.parse_args()


def run_powerfit_instance(model, vol, rotmat, args, n):

    pf = PowerFitter()
    pf.map = vol
    pf.model = model
    pf.rotations = rotmat

    pf.resolution = args.resolution
    pf.laplace = args.laplace
    pf.core_weighted = args.core_weighted

    sol = pf.search()
    sol.save(os.path.join(args.directory, 'lcc_{:d}.mrc'.format(n)),
            os.path.join(args.directory, 'rotmat_{:d}.npy'.format(n)),
            os.path.join(args.directory, 'rotmat_ind_{:d}.npy'.format(n)))


def mp_cpu_powerfit(model, vol, rotmat, args):

        # determine the number of jobs that should be created
        nrot = rotmat.shape[0]
        write('Requested number of processes: {:d}'.format(args.nproc))
        try:
            jobs = min(mp.cpu_count(), args.nproc)
            write('Maximum allowed processes: {:d}'.format(mp.cpu_count()))
        except NotImplementedError:
            jobs = args.nproc
        jobs = min(jobs, nrot)
        nrot_per_job = nrot//jobs

        write('Number of jobs created: {:d}'.format(jobs))
        write('Rotations sampled per job: {:d}'.format(nrot_per_job))

        write('Creating jobs.')
        processes = []
        for n in range(jobs):

            init_rot = n*nrot_per_job
            end_rot = init_rot + nrot_per_job
            if n == (jobs - 1):
                end_rot = None

            sub_rotmat = rotmat[init_rot: end_rot]

            processes.append(mp.Process(target=run_powerfit_instance,
                    args=(model, vol, sub_rotmat, args, n)))

        write('Starting jobs.')
        for n in range(jobs):
            processes[n].start()

        write('Waiting for jobs to end.')
        for n in range(jobs):
            processes[n].join()

        # combine results
        write('All jobs done.')
        write('Combining results.')
        best_lcc = Volume.fromfile(os.path.join(args.directory, 'lcc_0.mrc'))
        best_rotmat_ind = np.load(os.path.join(args.directory, 'rotmat_ind_0.npy'))
        for n in range(1, jobs):
            f_lcc = os.path.join(args.directory, 'lcc_{:d}.mrc'.format(n))
            f_rotmat_ind = os.path.join(args.directory, 'rotmat_ind_{:d}.npy'.format(n))

            lcc = Volume.fromfile(f_lcc)
            rotmat_ind = np.load(f_rotmat_ind) + nrot_per_job*n

            ind = lcc.array > best_lcc.array
            best_lcc.array[ind] = lcc.array[ind]
            best_rotmat_ind[ind] = rotmat_ind[ind]
        sol = Solutions(best_lcc, rotmat, best_rotmat_ind)

        write('Removing intermediate files')
        for n in range(jobs):
            f_lcc = os.path.join(args.directory, 'lcc_{:d}.mrc'.format(n))
            f_rotmat_ind = os.path.join(args.directory, 'rotmat_ind_{:d}.npy'.format(n))
            f_rotmat = os.path.join(args.directory, 'rotmat_{:d}.npy'.format(n))

            os.remove(f_lcc)
            os.remove(f_rotmat_ind)
            os.remove(f_rotmat)

        return sol


def cpu_powerfit(model, vol, rotmat, args):

    pf = PowerFitter()
    pf.map = vol
    pf.model = model
    pf.rotations = rotmat

    pf.resolution = args.resolution
    pf.laplace = args.laplace
    pf.core_weighted = args.core_weighted

    sol = pf.search()

    return sol


def gpu_powerfit(queue, model, vol, rotmat, args):

    pf = PowerFitter()
    pf.map = vol
    pf.model = model
    pf.rotations = rotmat

    pf.resolution = args.resolution
    pf.laplace = args.laplace
    pf.core_weighted = args.core_weighted
    pf.queue = queue

    sol = pf.search()

    return sol

def write(line):
    if stdout.isatty():
        print(line)
    logging.info(line)

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: 
            raise

def main():

    args = parse_args()

    mkdir_p(args.directory)

    logging.basicConfig(filename=os.path.join(args.directory, 'powerfit.log'), 
            level=logging.INFO, format='%(asctime)s %(message)s')

    time0 = time()

    vol = Volume.fromfile(args.map)
    write('Density data read from: {:s}'.format(args.map.name))
    write('Resolution of data: {:.2f}'.format(args.resolution))
    write('Initial shape of density data: {:}'.format(str(vol.shape)))

    if not args.no_resampling:
        resampling_factor = vol.voxelspacing/(0.25*args.resolution)
        if resampling_factor < 0.9:
            write('Old voxel spacing: {:.2f}'.format(vol.voxelspacing))
            vol = volume.resample(vol, factor=resampling_factor)
            write('Resamped density to 1/4 of resolution voxel spacing')
            write('New voxel spacing: {:.2f}'.format(vol.voxelspacing))
            write('Shape of density data reduced to: {:}'.format(str(vol.shape)))

    if not args.no_trimming:
        if args.trimming_cutoff is None:
            trimming_cutoff = 0.1*vol.array.max()
        else:
            trimming_cutoff = args.trimming_cutoff
        vol = volume.trim(vol, trimming_cutoff)

        write('Trimming cutoff set to: {:.3f}'.format(trimming_cutoff))
        write('Shape of density data after trimming: {:s}'.format(str(vol.shape)))

    vol = volume.resize_radix235(vol)
    write('Final shape of density data: {:}'.format(str(vol.shape)))

    model = PDB.fromfile(args.model)
    write('High-resolution model read from: {:s}'.format(args.model.name))
    if args.chain is not None:
        model = model.select('chain', args.chain)
        if model.data.size == 0:
            raise ValueError('Chain is not available in structure.')
        write('Selected chain: {:s}'.format(args.chain))

    q, w, a = proportional_orientations(args.angle)
    rotmat = quat_to_rotmat(q)
    write(u'Requested rotational sampling density: {:.2f}\N{DEGREE SIGN}'.format(args.angle))
    write(u'Real rotational sampling density: {:.2f}\N{DEGREE SIGN}.'.format(a))
    write('Total number of rotations sampled: {:d}'.format(len(rotmat)))

    write('Laplace pre-filter: {:}'.format(args.laplace))
    write('Core-weighted local cross correlation: {:}'.format(args.core_weighted))

    queue = None
    if args.gpu:
        queue = get_queue()

    if queue is None:
        if args.gpu:
            write('GPU-queue not found. Falling back on CPU-implementation.')
        write('Using CPU-version.')

        if args.nproc > 1:
            sol = mp_cpu_powerfit(model, vol, rotmat, args)
        else:
            sol = cpu_powerfit(model, vol, rotmat, args)
    else:
        write('Using GPU-accelerated search.')
        sol = gpu_powerfit(queue, model, vol, rotmat, args)

    write('Searching done. Analyzing solutions.')
    sol.generate_local_solutions()
    write('Found {:d} non-redundant solutions.'.format(len(sol._local_solutions)))
    write('Saving raw results.')
    sol.save(lcc_fname=os.path.join(args.directory, 'lcc.mrc'), 
            rotmat_fname=os.path.join(args.directory, 'rotmat.npy'),
            rotmat_ind_fname=os.path.join(args.directory, 'rotmat_ind.npy'))
    write('Writing top {:d} models to file.'.format(args.num))
    sol.write_pdb(model, num=args.num, fbase=os.path.join(args.directory, 'fit'))
    sol.write_local_solutions(os.path.join(args.directory, 'solutions.out'))

    tot_time = time() - time0
    m, s = divmod(int(round(tot_time)), 60)
    write('Total time required: {:d}m {:d}s'.format(m ,s))


if __name__=='__main__':
    main()
